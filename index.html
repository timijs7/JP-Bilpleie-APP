<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JP-Bilpleie</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="JP-Bilpleie" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />
  
  <!-- PDF: html2canvas + jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
     body { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif; margin:0; padding:16px; background:#f7f7fb; display: flex; justify-content: center;}
    .card { width: 100%; max-width: 980px; margin: 0 auto; padding: 16px; border-radius: 16px; background:#fff; box-shadow: 0 6px 24px rgba(0,0,0,0.08); }
    html, body {margin: 0; padding: 0; max-width: 100%;overflow-x: hidden;font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;background: #f7f7fb;}
    .container {display: flex; justify-content: center; padding: 16px; box-sizing: border-box;}
    .logo-top { text-align:center; margin-bottom:12px; }
    .logo-img { width:64px; height:64px; border-radius:12px; object-fit:contain; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    h2 { font-size: 20px; font-weight:700; color:#000; margin:20px 0 10px; border-bottom:2px solid #0a84ff; padding-bottom:4px; }
    label { display:block; font-weight:700; margin-top:12px; color:#000; }
    input, textarea, select { width:100%; padding:10px; border-radius:10px; border:1px solid #ccc; font-size:16px; box-sizing:border-box; background:#fff; }
    textarea { min-height:80px; }
    button { margin-top:16px; padding:12px 16px; border:0; border-radius:10px; font-size:16px; cursor:pointer; }
    .primary { background:#15803d; color:#fff; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > div { flex:1; min-width:240px; }
    .small { font-size:12px; color:#666; }
    .msg { margin-top:12px; }
    .hidden { display:none !important; }
    .thumbs{display:grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap:10px; margin-top:8px;}
    .thumb{position:relative; width:100%; aspect-ratio:1/1; border-radius:12px; overflow:hidden; border:1px solid #e5e7eb; background:#f8fafc;}
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; cursor:pointer; }
    .thumb .thumb-del{position:absolute; top:1px; right:4px; width:28px; height:28px; border:0; border-radius:50%; background:rgba(17,24,39,.9); color:#fff; display:flex; align-items:center;justify-content:center;font-size:12px; line-height:1; padding:0; cursor:pointer;}
    .thumb .thumb-del:hover{ background:#ef4444; }

    .work-table{width:100%;border-collapse:collapse;font-size:13px}
    .work-table th,.work-table td{border:1px solid #d1d5db;padding:8px 10px;vertical-align:top}
    .work-table th{background:#f3f4f6;text-align:left}
    .badge-yes{background:#dcfce7;color:#166534;padding:2px 8px;border-radius:12px;font-weight:700;display:inline-flex;gap:6px}
    .badge-no{background:#eef2f7;color:#6b7280;padding:2px 8px;border-radius:12px}

    /* Defektu shÄ“ma */
    .defect-wrap2 { border:1px dashed #bbb; border-radius:12px; padding:10px; background:#fff; }
    .defect-toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .defect-canvas {width: 60%; max-width: 350px; aspect-ratio: 2 / 3; background: #ffffff; border-radius: 12px; position: relative;margin: 0 auto; overflow: hidden;}
    .defect-canvas img.plan-img {width: 100%;height: 100%;object-fit: contain;display: block;user-select: none;-webkit-user-drag: none;pointer-events: none;}
    @media (max-width: 350px){ .defect-canvas { width: 100%; } }

    .pin { position:absolute; width:18px; height:18px; border-radius:50%; transform:translate(-50%,-50%); border:2px solid #fff; box-shadow:0 0 0 2px rgba(0,0,0,.15); cursor:grab; }
    .pin:active { cursor:grabbing; }
    .pin::after { content:attr(data-label); position:absolute; top:-22px; left:50%; transform:translateX(-50%); background:#111; color:#fff; font-size:10px; padding:2px 4px; border-radius:4px; white-space:nowrap; }
    .pin[data-type="scratch"]{ background:#ef4444; }

    /* PDF */
    .print-wrap { width: 794px; color:#111; }
    .pw-header { display:flex; justify-content:space-between; align-items:center; border-bottom:3px solid #0a84ff; padding-bottom:8px; margin-bottom:12px; }
    .pw-title { font-size:22px; font-weight:800; }
    .pw-doc { text-align:right; font-size:16px; line-height:1.4; }
    .kv { width:100%; border-collapse: collapse; }
    .kv th, .kv td { border:1px solid #d1d5db; padding:8px 10px; font-size:13px; vertical-align:top; }
    .kv th { background:#f3f4f6; text-align:left; width:32%; }
    .sec-title { font-size:14px; font-weight:800; margin:14px 0 6px; text-transform:uppercase; letter-spacing:.4px; color:#0f172a; }
    .text-box { min-height:44px; padding:8px; border:1px solid #d1d5db; border-radius:8px; background:#fff; font-size:13px; white-space:pre-wrap; }
    .chips { display:flex; flex-wrap:wrap; gap:8px; }
    .chip { border:1px solid #c7cbd1; border-radius:999px; padding:4px 10px; font-size:12px; background:#f8fafc; }
    .photos-block { margin-top:8px; }
    .photo-item { margin-bottom:10px; page-break-inside: avoid; }
    .photo-item img { width:70%; border:1px solid #e5e7eb; border-radius:8px; display:block; }
    .photo-cap { font-size:12px; color:#475569; margin-top:4px; }

    .print-wrap, .print-wrap *{-webkit-text-size-adjust: none !important; /* iOS: neliec automÄtiski palielinÄt */text-size-adjust: none !important;}

    .print-wrap{ font-size: 13px; line-height: 1.35; }
    .pw-title{ font-size: 20px; }
    .kv th, .kv td, .text-box{ font-size: 12.5px; }
    .sec-title{ font-size: 13px; }

    .success-backdrop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:9999}
    .success-backdrop.show{display:flex}
    .success-pop{background:#fff;min-width:320px;max-width:92vw;border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.35);padding:22px 24px;text-align:center;opacity:0;transform:scale(.96);transition:opacity .18s ease,transform .18s ease}
    .success-pop.show{opacity:1;transform:scale(1)}
    .success-pop .icon{width:64px;height:64px;border-radius:50%;margin:6px auto 10px;display:grid;place-items:center;background:#dcfce7;color:#166534;font-size:30px}
    .success-pop h3{margin:4px 0 0;font-size:24px}
    .success-pop p{margin:6px 0 0;font-size:14px;color:#334155}
    .success-pop .btn{margin-top:12px;padding:10px 14px;border:0;border-radius:10px;background:#0a84ff;color:#fff;cursor:pointer}
    
    .works-list{display:grid;grid-template-columns:1fr;gap:10px;margin:12px 0;}
    @media (min-width:640px){ .works-list{ grid-template-columns:1fr 1fr; } }
    
    .work-item{ display:block; }
    .work-item input{ position:absolute; opacity:0; pointer-events:none; }
    .work-item .box{display:flex; align-items:center; gap:12px;padding:12px 14px; min-height:52px;border:1.5px solid #d0d7de; border-radius:12px;background:#fff;-webkit-tap-highlight-color: transparent;}
    .work-item .check{width:22px; height:22px; flex:0 0 22px;border:2px solid #94a3b8; border-radius:6px;background:#fff;}
    .work-item input:checked + .box{ border-color:#2563eb; background:#eff6ff; }
    .work-item input:checked + .box .check{background:#2563eb; border-color:#2563eb;box-shadow: inset 0 0 0 3px #fff;}
    .work-item .txt{ font-size:16px; line-height:1.25; color:#0f172a; }
    .work-item .txt b{ font-weight:700; }
  </style>
</head>
<body>
  <div class="card" id="formCard">
    <div class="logo-top">
      <img src="icons/icon-192.png" alt="Logo" class="logo-img">
    </div>

    <form id="form">
      <h2>Kunde</h2>
      <div class="row">
        <div>
          <label>Kundetype</label>
          <select id="companyType">
            <option value="business">Juridisk person (bedrift)</option>
            <option value="private">Privat (uten bedrift)</option>
          </select>
        </div>
        <div id="businessBlock">
          <label>Bedrift</label>
          <select id="companySelect">
            <option value="" selected disabled>â€” Velg bedrift â€”</option>
            <option value="ferda">Ferda</option>
            <option value="motoforum">Motoforum</option>
            <option value="other">Annenâ€¦</option>
          </select>
          <div id="otherCompanyBlock" class="hidden" style="margin-top:8px">
            <input id="otherCompany" placeholder="Annet bedriftsnavn">
          </div>
        </div>
      </div>

      <h2>KjÃ¸retÃ¸y</h2>
      <div class="row">
        <div>
          <label>Ny eller brukt bil</label>
          <select id="carCondition" required>
            <option value="new">Ny</option>
            <option value="used">Brukt</option>
          </select>
        </div>
        <div>
          <label>Dato</label>
          <input id="date" type="date" required />
        </div>
      </div>

      <div class="row">
        <div><label>Merke</label><input id="brand" required /></div>
        <div><label>Modell</label><input id="model" /></div>
        <div><label>VIN / Reg.nr.</label><input id="vin" required /></div>
        <div><label>Kilometerstand (km)</label><input id="mileage" type="number" inputmode="numeric" min="0" step="1" /></div>
      </div>

      <label>Bilder av bilen</label>
      <input id="photos" type="file" accept="image/*" multiple capture="environment" required />
      <div class="thumbs" id="thumbs"></div>

      <h2>Arbeid</h2>
<div class="works-list" role="group" aria-labelledby="arbeid-title">
  <label class="work-item">
    <input type="checkbox" class="work" value="innvendig_vask">
    <div class="box"><span class="check" aria-hidden="true"></span><span class="txt">ğŸ§½ <b>Innvendig vask</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="utvendig_vask_voks">
    <div class="box"><span class="check"></span><span class="txt">ğŸš¿âœ¨ <b>Utvendig vask + voks</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="innvendig_utvendig_vask_voks">
    <div class="box"><span class="check"></span><span class="txt">ğŸ§½ğŸš¿âœ¨ <b>Innvendig/utvendig vask + voks</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="polering1_voks">
    <div class="box"><span class="check"></span><span class="txt">1ï¸âƒ£ğŸŒ€ <b>1-stegs polering + voks</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="polering2_voks">
    <div class="box"><span class="check"></span><span class="txt">2ï¸âƒ£ğŸŒ€ <b>2-stegs polering + voks</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="keramisk_coating">
    <div class="box"><span class="check"></span><span class="txt">ğŸ›¡ <b>Keramisk coating</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="fullshine_pakke">
    <div class="box"><span class="check"></span><span class="txt">âœ¨ <b>Fullshine pakke</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="express_utvendig_vask">
    <div class="box"><span class="check"></span><span class="txt">âš¡ğŸš¿ <b>Express utvendig vask</b></span></div>
  </label>

  <label class="work-item">
    <input type="checkbox" class="work" value="express_innvendig_vask">
    <div class="box"><span class="check"></span><span class="txt">âš¡ğŸ§½ <b>Express innvendig vask</b></span></div>
  </label>
</div>

<label>Andre arbeider / merknader</label>
<textarea id="workNotes" placeholder="Tilleggsbeskrivelse av utfÃ¸rt arbeid"></textarea>

      <h2>Skader</h2>
      <div class="defect-wrap2">
        <div class="defect-toolbar" style="justify-content:space-between">
          <button type="button" id="clearPins">TÃ¸m markeringer</button>
        </div>
        <div class="defect-canvas" id="defectCanvas"><!-- bilde/SVG lastes av JS --></div>
      </div>

      <label>Skader (tekst)</label>
      <textarea id="defects" placeholder="Beskriv skader hvis aktuelt"></textarea>

      <h2>Kommentarer</h2>
      <textarea id="comments" placeholder="Tilleggsinformasjon"></textarea>

      <button type="submit" class="primary">FullfÃ¸r</button>
      <div class="msg" id="msg"></div>
    <div id="offlineStatus" style="margin-top: 20px; padding: 15px; border-radius: 8px; background: #f3f4f6; display: none;">
      <div style="font-weight: bold; margin-bottom: 8px;">ğŸ“¥ NesÅ«tÄ«tie faili:</div>
      <div id="offlineCount">Nav nesÅ«tÄ«tu failu</div>
      <div id="offlineSize" style="color: #666; font-size: 0.9em;"></div>
      <button type="button" id="retryButton" style="margin-top: 10px; padding: 8px 12px; background: #15803d; color: white; border: none; border-radius: 6px; display: none;">
        MÄ“Ä£inÄt sÅ«tÄ«t vÄ“lreiz
      </button>
    </div>
    </form>
  </div>

<script>
// Funkcija izmÄ“ra formatÄ“Å¡anai
function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Funkcija offline statusa atjauninÄÅ¡anai
async function updateOfflineStatus() {
    const statusDiv = document.getElementById('offlineStatus');
    const countDiv = document.getElementById('offlineCount');
    const sizeDiv = document.getElementById('offlineSize');
    const retryButton = document.getElementById('retryButton');

    try {
        const items = await idbAll();
        let totalSize = 0;
        items.forEach(item => {
            if (item.dataUri) {
                totalSize += item.dataUri.length;
            }
        });

        if (items.length > 0) {
            statusDiv.style.display = 'block';
            countDiv.textContent = `${items.length} ${items.length === 1 ? 'fails' : 'faili'} gaida sÅ«tÄ«Å¡anu`;
            sizeDiv.textContent = `KopÄ“jais izmÄ“rs: ${formatBytes(totalSize)}`;
            
            if (navigator.onLine) {
                retryButton.style.display = 'block';
            } else {
                retryButton.style.display = 'none';
            }
        } else {
            statusDiv.style.display = 'none';
        }
    } catch (e) {
        console.error('KÄ¼Å«da pÄrbaudot offline status:', e);
    }
}

// Pievienojam retry pogas funkcionalitÄti
document.getElementById('retryButton').addEventListener('click', async () => {
    if (navigator.onLine) {
        const result = await flushQueue();
        updateOfflineStatus();
        if (result.sent > 0) {
            showCenterSuccess('NosÅ«tÄ«ts!', `${result.sent} ${result.sent === 1 ? 'fails nosÅ«tÄ«ts' : 'faili nosÅ«tÄ«ti'}`);
        }
    }
});

// PÄrbaudÄm statusu regulÄri un kad mainÄs online/offline stÄvoklis
window.addEventListener('online', updateOfflineStatus);
window.addEventListener('offline', updateOfflineStatus);
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        updateOfflineStatus();
    }
});

// SÄkotnÄ“jÄ statusa pÄrbaude
updateOfflineStatus();
  const DRIVE_URL = "https://script.google.com/macros/s/AKfycbxVa38bi3gpRpy99fnvfSRtHDt8naGRo2haCpG7BraxdnwQHwhcnQMfvoUo7VIZTkMx/exec";
  const PREVIEW_LOCAL = false;

  // ---- UI / foto ----
  const form = document.getElementById("form");
  const msg = document.getElementById("msg");
  const companyTypeEl = document.getElementById("companyType");
  const businessBlock = document.getElementById("businessBlock");
  const companySelect = document.getElementById("companySelect");
  const otherCompanyBlock = document.getElementById("otherCompanyBlock");
  const otherCompany = document.getElementById("otherCompany");
  const dateInput = document.getElementById("date");
  const brandEl = document.getElementById("brand");
  const vinEl = document.getElementById("vin");
  const mileageEl = document.getElementById("mileage");
  const modelEl = document.getElementById("model");
  const photosEl = document.getElementById("photos");
  const thumbsEl = document.getElementById("thumbs");

  if (!dateInput.value) { dateInput.value = new Date().toISOString().slice(0,10); }

  function refreshCompanyUI() {
    const isBusiness = (companyTypeEl.value === 'business');
    const isOther    = isBusiness && (companySelect.value === 'other');
    businessBlock.classList.toggle('hidden', !isBusiness);
    otherCompanyBlock.classList.toggle('hidden', !isOther);
    companySelect.required = isBusiness;
    otherCompany.required  = isOther;
    if (!isBusiness) { companySelect.value = ''; otherCompany.value = ''; }
  }

  companySelect.addEventListener('invalid', e => e.target.setCustomValidity('Velg bedrift'));
  companySelect.addEventListener('input',  e => e.target.setCustomValidity(''));
  otherCompany.addEventListener('invalid', e => e.target.setCustomValidity('Skriv inn bedriftsnavn'));
  otherCompany.addEventListener('input',  e => e.target.setCustomValidity(''));

  companyTypeEl.addEventListener('change', refreshCompanyUI);
  companySelect.addEventListener('change', refreshCompanyUI);
  refreshCompanyUI();

let photoData = [];              
let fileAgg; let canAgg = false;
try { fileAgg = new DataTransfer(); canAgg = true; } catch(_) {}

function updatePhotoCount(){
  const c = document.getElementById('photoCount');
  if (c) c.textContent = photoData.length ? `(${photoData.length})` : '';
  if (!canAgg) photosEl.setCustomValidity(photoData.length ? '' : 'Legg til minst ett bilde');
}

function isHeic(file){
  return /hei(c|f)/i.test(file.type) || /\.hei(c|f)$/i.test(file.name);
}
function blobToDataURL(blob){
  return new Promise((res, rej)=>{
    const fr = new FileReader(); fr.onload = () => res(fr.result);
    fr.onerror = rej; fr.readAsDataURL(blob);
  });
}
async function fileToJpegDataUrl(file){
  // MaksimÄlais attÄ“la izmÄ“rs (800px platums vai augstums)
  const MAX_IMAGE_SIZE = 800;
  // SÄkotnÄ“jÄ kvalitÄte
  const INITIAL_QUALITY = 0.7;
  
  try {
    let imageData;
    
    // HEIC failu konvertÄ“Å¡ana
    if (isHeic(file) && window.heic2any){
      try {
        const out = await heic2any({ 
          blob: file, 
          toType: 'image/jpeg', 
          quality: INITIAL_QUALITY 
        });
        imageData = await blobToDataURL(out);
      } catch(e){ 
        console.warn('HEIC konvertÄ“Å¡anas kÄ¼Å«da:', e);
        imageData = await readFileAsDataURL(file);
      }
    } else {
      imageData = await readFileAsDataURL(file);
    }

    // IegÅ«stam attÄ“la izmÄ“rus
    const dimensions = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ width: img.width, height: img.height });
      img.src = imageData;
    });

    // AprÄ“Ä·inam nepiecieÅ¡amo samazinÄÅ¡anas pakÄpi
    const scale = Math.min(1, MAX_IMAGE_SIZE / Math.max(dimensions.width, dimensions.height));
    const targetWidth = Math.round(dimensions.width * scale);
    const targetHeight = Math.round(dimensions.height * scale);

    // SamazinÄm attÄ“lu
    const canvas = document.createElement('canvas');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    
    const ctx = canvas.getContext('2d');
    const img = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = imageData;
    });
    
    // ZÄ«mÄ“jam attÄ“lu ar labÄku kvalitÄti
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

    // MÄ“Ä£inÄm daÅ¾Ädas kvalitÄtes, lÄ«dz iegÅ«stam pietiekami mazu failu
    let quality = INITIAL_QUALITY;
    let result = canvas.toDataURL('image/jpeg', quality);
    
    // Ja fails joprojÄm ir par lielu (virs 500KB), mÄ“Ä£inÄm samazinÄt kvalitÄti
    while (result.length > 500 * 1024 && quality > 0.3) {
      quality -= 0.1;
      result = canvas.toDataURL('image/jpeg', quality);
    }

    console.log(`AttÄ“ls apstrÄdÄts: ${targetWidth}x${targetHeight}, kvalitÄte: ${quality.toFixed(2)}, izmÄ“rs: ${(result.length/1024).toFixed(1)}KB`);
    
    return result;
  } catch (error) {
    console.error('KÄ¼Å«da apstrÄdÄjot attÄ“lu:', error);
    throw new Error('NeizdevÄs apstrÄdÄt attÄ“lu. LÅ«dzu, izmÄ“Ä£iniet citu attÄ“lu.');
  }
}

function addThumb(item){
  const wrap = document.createElement('div'); wrap.className = 'thumb';
  const img  = document.createElement('img'); img.src = item.dataUrl; img.alt = item.name||'Bilde';
  const del  = document.createElement('button'); del.type='button'; del.className='thumb-del'; del.title='Slett'; del.textContent='Ã—';

  del.addEventListener('click', () => {
    const idx = photoData.indexOf(item);
    if (idx > -1) photoData.splice(idx,1);

    if (canAgg) {
      fileAgg = new DataTransfer();
      for (const p of photoData) if (p._file) fileAgg.items.add(p._file);
      try { photosEl.files = fileAgg.files; } catch(_) {}
    }
    wrap.remove();
    updatePhotoCount();
  });

  wrap.appendChild(img);
  wrap.appendChild(del);
  thumbsEl.appendChild(wrap);
}

photosEl.addEventListener('change', async (e) => {
  const MAX_TOTAL_PHOTOS = 20; // MaksimÄlais attÄ“lu skaits
  const files = Array.from(e.target.files || []);
  
  // PÄrbaudam kopÄ“jo attÄ“lu skaitu
  if (photoData.length + files.length > MAX_TOTAL_PHOTOS) {
    msg.textContent = `Nevar pievienot vairÄk par ${MAX_TOTAL_PHOTOS} attÄ“liem`;
    return;
  }

  msg.textContent = "ApstrÄdÄju attÄ“lus...";
  let successCount = 0;
  
  try {
    for (const f of files) {
      try {
        // PÄrbaudam faila izmÄ“ru
        if (f.size > 15 * 1024 * 1024) { // 15MB limits oriÄ£inÄlajam failam
          console.warn(`Fails ${f.name} ir par lielu (${(f.size/1024/1024).toFixed(1)}MB)`);
          continue;
        }

        if (canAgg) fileAgg.items.add(f);
        const jpeg = await fileToJpegDataUrl(f);
        const item = { name: f.name, type: 'image/jpeg', dataUrl: jpeg, _file: f };
        photoData.push(item);
        addThumb(item);
        successCount++;
      } catch (err) {
        console.error(`KÄ¼Å«da apstrÄdÄjot failu ${f.name}:`, err);
      }
    }

    if (canAgg) {
      try { photosEl.files = fileAgg.files; } catch(_) {}
    }
    
    updatePhotoCount();
    
    // PaziÅ†ojums par rezultÄtu
    if (successCount === 0) {
      msg.textContent = "NeizdevÄs pievienot attÄ“lus. PÄrbaudiet vai tie nav par lielu.";
    } else if (successCount < files.length) {
      msg.textContent = `Pievienoti ${successCount} no ${files.length} attÄ“liem. DaÅ¾i attÄ“li bija par lielu.`;
    } else {
      msg.textContent = "";
    }
  } catch (err) {
    console.error('KÄ¼Å«da pievienojot attÄ“lus:', err);
    msg.textContent = "KÄ¼Å«da pievienojot attÄ“lus. MÄ“Ä£iniet vÄ“lreiz ar mazÄkiem attÄ“liem.";
  }
});

function readFileAsDataURL(file){
  return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); });
}
async function downscaleImage(dataUrl, maxSize, initialQuality = 0.9) {
  const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2MB maksimÄlais izmÄ“rs
  let quality = initialQuality;
  let attempt = 0;
  const maxAttempts = 5;

  while (attempt < maxAttempts) {
    try {
      const img = await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('AttÄ“la ielÄde neizdevÄs'));
        img.src = dataUrl;
      });

      // AprÄ“Ä·inÄm izmÄ“rus
      let ratio = Math.max(img.width, img.height) / maxSize;
      let w = ratio > 1 ? Math.round(img.width / ratio) : img.width;
      let h = ratio > 1 ? Math.round(img.height / ratio) : img.height;

      // Ja attÄ“ls ir Ä¼oti liels, samazinÄm vÄ“l vairÄk
      if (w * h > 4000000) { // 4 megapikseÄ¼i
        ratio = Math.sqrt((w * h) / 4000000);
        w = Math.round(w / ratio);
        h = Math.round(h / ratio);
      }

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      canvas.getContext('2d').drawImage(img, 0, 0, w, h);
      
      const resultDataUrl = canvas.toDataURL('image/jpeg', quality);
      
      // PÄrbaudam izmÄ“ru
      const size = Math.ceil(resultDataUrl.length * 0.75); // aptuvens base64 izmÄ“rs baitos
      
      if (size <= MAX_FILE_SIZE) {
        return resultDataUrl;
      }
      
      // Ja fails joprojÄm ir par lielu, samazinÄm kvalitÄti
      quality *= 0.8;
      attempt++;
      
      console.log(`AttÄ“ls joprojÄm par lielu (${(size/1024/1024).toFixed(2)}MB), mÄ“Ä£inu ar kvalitÄti ${quality}`);
    } catch (e) {
      console.error('KÄ¼Å«da apstrÄdÄjot attÄ“lu:', e);
      throw e;
    }
  }
  
  throw new Error('NeizdevÄs pietiekami samazinÄt attÄ“lu. LÅ«dzu, izvÄ“lieties mazÄku attÄ“lu.');
}

function resetPhotos(){
  photoData = [];
  thumbsEl.innerHTML = '';
  try { fileAgg = new DataTransfer(); photosEl.files = fileAgg.files; } catch(_) {}
  updatePhotoCount();
}

  // Defektu shÄ“ma
  const defectCanvasEl = document.getElementById('defectCanvas');
  const clearPinsBtn = document.getElementById('clearPins');
  let activeType = 'scratch';
  let pins = [];

  clearPinsBtn.addEventListener('click', () => { pins = []; renderPins(); });

  function loadPlan(){
    defectCanvasEl.innerHTML = getPlanSvg();
    renderPins();
  }
  loadPlan();

  defectCanvasEl.addEventListener('click', (e) => {
    if (e.target.classList.contains('pin')) return;
    const r = defectCanvasEl.getBoundingClientRect();
    const xRel = (e.clientX - r.left) / r.width;
    const yRel = (e.clientY - r.top) / r.height;
    const label = prompt("Skademerknad (valgfritt):", "");
    pins.push({ xRel, yRel, label: label||"", type: activeType });
    renderPins();
  });

  function renderPins(){
    defectCanvasEl.querySelectorAll('.pin').forEach(n => n.remove());
    for (const p of pins) {
      const pin = document.createElement('div');
      pin.className = 'pin';
      pin.dataset.type = p.type;
      pin.dataset.label = p.label;
      pin.style.left = (p.xRel*100)+'%';
      pin.style.top  = (p.yRel*100)+'%';
      pin.title = (p.label ? p.label + " â€¢ " : "") + "Dra for Ã¥ flytte, dobbeltklikk for Ã¥ slette";

      pin.addEventListener('pointerdown', (ev) => {
        ev.preventDefault();
        const start = defectCanvasEl.getBoundingClientRect();
        const sx = ev.clientX, sy = ev.clientY;
        const ox = p.xRel, oy = p.yRel;
        function move(ev2){
          p.xRel = Math.min(0.995, Math.max(0.005, ox + (ev2.clientX - sx)/start.width));
          p.yRel = Math.min(0.995, Math.max(0.005, oy + (ev2.clientY - sy)/start.height));
          pin.style.left = (p.xRel*100)+'%';
          pin.style.top  = (p.yRel*100)+'%';
        }
        function up(){ window.removeEventListener('pointermove',move); window.removeEventListener('pointerup',up); }
        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', up);
      });

      pin.addEventListener('dblclick', () => {
        const idx = pins.indexOf(p);
        if (idx > -1) { pins.splice(idx,1); renderPins(); }
      });

      defectCanvasEl.appendChild(pin);
    }
  }

  function getPlanSvg(){
    return `<img src="icons/plan.png" alt="Bilskisse (topp)" class="plan-img">`;
  }

  // Datu sagatavoÅ¡ana
  function buildEntry(){
    const companyType = companyTypeEl.value;
    let companyCode = "private";
    let companyName = "Privat";
    if (companyType === "business") {
      companyCode = companySelect.value || "other";
      companyName = companySelect.value === "other" ? (otherCompany.value || "").trim() : (companySelect.options[companySelect.selectedIndex]?.text || "").trim();
      if (!companyName) throw new Error("Velg bedrift eller skriv inn navn.");
    }
    const works = Array.from(document.querySelectorAll(".work:checked")).map(cb => cb.value);
    return {
      date: dateInput.value,
      companyType, companyCode, companyName,
      car: { condition: document.getElementById("carCondition").value, brand: brandEl.value.trim(), model: modelEl.value.trim(), vinOrReg: vinEl.value.trim(), mileage: mileageEl.value || "" },
      works,
      workNotes: document.getElementById("workNotes").value.trim(),
      defectsText: document.getElementById("defects").value.trim(),
      comments: document.getElementById("comments").value.trim(),
      photos: photoData
    };
  }

  const WORK_NAMES = {
    innvendig_vask: "Innvendig vask",
    utvendig_vask_voks: "Utvendig vask + voks",
    innvendig_utvendig_vask_voks: "Innvendig/utvendig vask + voks",
    polering1_voks: "1-stegs polering + voks",
    polering2_voks: "2-stegs polering + voks",
    keramisk_coating: "Keramisk coating",
    fullshine_pakke: "Fullshine pakke",
    express_utvendig_vask: "Express utvendig vask",
    express_innvendig_vask: "Express innvendig vask"
  };

  // PDF Ä£enerÄ“Å¡ana
  async function makePdfDataUrlFromForm(entry) {
  // 1) Defektu shÄ“ma â†’ PNG (no redzamÄ canvasa)
  let defectImgData = '';
  try {
    const defEl = document.getElementById('defectCanvas');
    const defCanvas = await html2canvas(defEl, {
      scale: 2, useCORS: true, backgroundColor: '#ffffff',
      windowWidth: defEl.clientWidth, windowHeight: defEl.clientHeight,
      scrollX: 0, scrollY: 0
    });
    defectImgData = defCanvas.toDataURL('image/png');
  } catch {}

  // 2) UzbÅ«vÄ“jam drukas saturu
  const wrap = document.createElement('div');
  wrap.className = 'print-wrap';
  wrap.innerHTML = `
    <div class="pw-header">
      <div style="display:flex;align-items:center;gap:10px">
        <img src="icons/icon-192.png" alt="Ikon" width="62" height="62" style="border-radius:6px" />
        <div class="pw-title">JP-Bilpleie</div>
      </div>
      <div class="pw-doc"><b>Dato:</b> ${entry.date||''}</div>
    </div>

    <div class="sec-title">Kunde</div>
    <table class="kv">
      <tr><th>Type</th><td>${entry.companyType==='business'?'Juridisk person (bedrift)':'Privat'}</td></tr>
      <tr><th>Bedrift</th><td>${entry.companyType==='business' ? (entry.companyName||'') : 'â€”'}</td></tr>
    </table>

    <div class="sec-title">KjÃ¸retÃ¸y</div>
    <table class="kv">
      <tr><th>Tilstand</th><td>${entry.car.condition==='new'?'Ny':'Brukt'}</td></tr>
      <tr><th>Merke / Modell</th><td>${(entry.car.brand||'')+' '+(entry.car.model||'')}</td></tr>
      <tr><th>VIN / Reg.nr.</th><td>${entry.car.vinOrReg||''}</td></tr>
      <tr><th>Kilometerstand (km)</th><td>${entry.car.mileage||''}</td></tr>
    </table>

    <div class="sec-title">UtfÃ¸rt arbeid</div>
    <table class="work-table">
      <thead><tr><th>Arbeid</th><th>Status</th></tr></thead>
      <tbody id="worksTbody"></tbody>
    </table>
    <div style="margin-top:6px;font-size:12px">
      <b>Oppsummering:</b> <span id="worksSummary">â€”</span>
    </div>
    <div style="height:6px"></div>
    <div class="text-box">${(entry.workNotes||'').replace(/</g,'&lt;')}</div>

    <div class="sec-title">Skader</div>
    ${defectImgData ? `<img src="${defectImgData}" style="width:50%;border:1px solid #e5e7eb;border-radius:8px">` : '<div class="text-box">â€”</div>'}
    <div style="height:6px"></div>
    <div class="text-box">${(entry.defectsText||'').replace(/</g,'&lt;')}</div>

    <div class="sec-title">Kommentarer</div>
    <div class="text-box">${(entry.comments||'').replace(/</g,'&lt;')}</div>

    <div class="sec-title">Bilder</div>
    <div class="photos-block" id="photosBlock"></div>
  `;

  // Tabula ar âœ“/â€” statusu
  const tbody = wrap.querySelector('#worksTbody');
  const selected = new Set(entry.works || []);
  Object.entries(WORK_NAMES).forEach(([code, name]) => {
    const tr = document.createElement('tr');
    const done = selected.has(code);
    tr.innerHTML = `
      <td>${name}</td>
      <td>${done ? '<span class="badge-yes">âœ“ UtfÃ¸rt</span>' : '<span class="badge-no">â€” Ikke</span>'}</td>`;
    tbody.appendChild(tr);
  });
  const picked = (entry.works || []).map(w => WORK_NAMES[w] || w);
  wrap.querySelector('#worksSummary').textContent = picked.length ? picked.join(', ') : 'â€”';

  // Foto
  const pb = wrap.querySelector('#photosBlock');
  (entry.photos||[]).forEach((p, i) => {
    const item = document.createElement('div');
    item.className = 'photo-item';
    item.innerHTML = `<img src="${p.dataUrl}" alt="Foto ${i+1}"><div class="photo-cap">Foto ${i+1}</div>`;
    pb.appendChild(item);
  });

  // 3) NeredzamÄ vietÄ, pÄ“c tam renderÄ“jam ar fiksÄ“tu â€œloguâ€ izmÄ“ru (vienÄdi telefonÄ un PC)
  const holder = document.createElement('div');
  holder.style.position = 'fixed'; holder.style.left = '-10000px'; holder.style.top = '0';
  holder.appendChild(wrap);
  document.body.appendChild(holder);

  const canvas = await html2canvas(wrap, {
    scale: 2, useCORS: true, backgroundColor: '#ffffff',
    windowWidth: 794, windowHeight: wrap.scrollHeight, scrollX: 0, scrollY: 0
  });

  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF('p','mm','a4');
  const pageWidth  = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const imgData   = canvas.toDataURL('image/jpeg', 0.95);
  const imgWidth  = pageWidth;
  const imgHeight = canvas.height * imgWidth / canvas.width;

  let heightLeft = imgHeight, position = 0;
  pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
  heightLeft -= pageHeight;
  while (heightLeft > 0) {
    pdf.addPage();
    position = heightLeft - imgHeight;
    pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
  }

  holder.remove();
  return pdf.output('datauristring');
}

  // SÅ«tÄ«t uz Drive
  async function sendPdfDataUriToDrive(entry, dataUri){
    if (!DRIVE_URL) throw new Error('Har ikke DRIVE_URL');

    const brandLabel = [entry.car.brand, entry.car.model].filter(Boolean).join('_') || 'uten_merke';
    const fileName = `contract_${brandLabel}_${entry.date||''}.pdf`.replace(/\s+/g,'_');
    const base64 = (dataUri.split('base64,')[1] || '');

    await fetch(DRIVE_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      body: JSON.stringify({
        fileName,
        pdfBase64: base64,
        companyCode: entry.companyCode,
        companyName: entry.companyName,
        date: entry.date,
        brand: entry.car.brand || "",
        model: entry.car.model || ""
      })
    });

    return { ok:true, hintFolder: `JP-Bilplei APP/${(entry.companyCode||'other')}/${(entry.date||'')}_${brandLabel}` };
  }

  // Center popup helpers
  function showCenterSuccess(text='Sendt!', sub=''){
    const bg = document.getElementById('successCenter');
    const pop = bg.querySelector('.success-pop');
    document.getElementById('successTitle').textContent = text;
    document.getElementById('successSub').textContent = sub || '';
    bg.classList.add('show');
    requestAnimationFrame(()=>pop.classList.add('show'));
  }
  function hideCenterSuccess(){
    const bg = document.getElementById('successCenter');
    const pop = bg.querySelector('.success-pop');
    pop.classList.remove('show');
    setTimeout(()=>bg.classList.remove('show'), 180);
  }
// ---- Improved IndexedDB Storage with Chunking ----
const DB_NAME = 'jpbilpleie';
const STORE = 'outbox';
const CHUNK_STORE = 'chunks';
const MAX_CHUNK_SIZE = 1024 * 1024; // 1MB chunks

function idbOpen() {
  return new Promise((res, rej) => {
    const req = indexedDB.open(DB_NAME, 2); // Increased version for new store
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      }
      if (!db.objectStoreNames.contains(CHUNK_STORE)) {
        const chunkStore = db.createObjectStore(CHUNK_STORE, { keyPath: 'id', autoIncrement: true });
        chunkStore.createIndex('fileId', 'fileId', { unique: false });
      }
    };
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}

// Split data into chunks
function splitIntoChunks(data) {
  const chunks = [];
  let offset = 0;
  while (offset < data.length) {
    chunks.push(data.slice(offset, offset + MAX_CHUNK_SIZE));
    offset += MAX_CHUNK_SIZE;
  }
  return chunks;
}

// Save chunks to IndexedDB
async function saveChunks(fileId, dataUri) {
  const db = await idbOpen();
  const tx = db.transaction(CHUNK_STORE, 'readwrite');
  const store = tx.objectStore(CHUNK_STORE);
  
  const chunks = splitIntoChunks(dataUri);
  const promises = chunks.map((chunk, index) => 
    new Promise((resolve, reject) => {
      const req = store.add({
        fileId,
        index,
        data: chunk,
        total: chunks.length
      });
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    })
  );
  
  await Promise.all(promises);
  db.close();
  return chunks.length;
}

// Get all chunks for a file
async function getChunks(fileId) {
  const db = await idbOpen();
  const tx = db.transaction(CHUNK_STORE, 'readonly');
  const store = tx.objectStore(CHUNK_STORE);
  const index = store.index('fileId');
  
  return new Promise((resolve, reject) => {
    const req = index.getAll(IDBKeyRange.only(fileId));
    req.onsuccess = () => {
      const chunks = req.result.sort((a, b) => a.index - b.index);
      resolve(chunks.map(c => c.data).join(''));
    };
    req.onerror = () => reject(req.error);
  });
}

// Delete chunks for a file
async function deleteChunks(fileId) {
  const db = await idbOpen();
  const tx = db.transaction(CHUNK_STORE, 'readwrite');
  const store = tx.objectStore(CHUNK_STORE);
  const index = store.index('fileId');
  
  const keys = await new Promise((resolve, reject) => {
    const req = index.getAllKeys(IDBKeyRange.only(fileId));
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  
  await Promise.all(keys.map(key => 
    new Promise((resolve, reject) => {
      const req = store.delete(key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    })
  ));
  
  db.close();
}

async function idbAdd(item) {
  const db = await idbOpen();
  const tx = db.transaction(STORE, 'readwrite');
  
  // Save metadata first
  const id = await new Promise((resolve, reject) => {
    const req = tx.objectStore(STORE).add({
      ...item,
      dataUri: null, // Don't store dataUri in metadata
      chunks: 0,
      addedAt: Date.now()
    });
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  
  // Then save chunks
  const chunkCount = await saveChunks(id, item.dataUri);
  
  // Update metadata with chunk count
  await new Promise((resolve, reject) => {
    const req = tx.objectStore(STORE).put({
      ...item,
      id,
      dataUri: null,
      chunks: chunkCount,
      addedAt: Date.now()
    });
    req.onsuccess = () => resolve();
    req.onerror = () => reject(req.error);
  });
  
  db.close();
  return id;
}

async function idbAll() {
  const db = await idbOpen();
  const tx = db.transaction(STORE, 'readonly');
  
  const items = await new Promise((resolve, reject) => {
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
  
  // Load chunks for each item
  for (const item of items) {
    if (item.chunks > 0) {
      item.dataUri = await getChunks(item.id);
    }
  }
  
  db.close();
  return items;
}

async function idbDel(id) {
  const db = await idbOpen();
  const tx = db.transaction(STORE, 'readwrite');
  
  await Promise.all([
    new Promise((resolve, reject) => {
      const req = tx.objectStore(STORE).delete(id);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    }),
    deleteChunks(id)
  ]);
  
  db.close();
}


// Improved upload with retry logic
async function uploadOne(entry, dataUri, retryCount = 3) {
  for (let i = 0; i < retryCount; i++) {
    try {
      console.log(`MÄ“Ä£inu sÅ«tÄ«t failu (mÄ“Ä£inÄjums ${i + 1}/${retryCount})...`);
      await sendPdfDataUriToDrive(entry, dataUri);
      console.log('Fails veiksmÄ«gi nosÅ«tÄ«ts!');
      return true;
    } catch (e) {
      console.warn(`KÄ¼Å«da sÅ«tot (mÄ“Ä£inÄjums ${i + 1}/${retryCount}):`, e);
      if (i < retryCount - 1) {
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
      }
    }
  }
  console.error('NeizdevÄs nosÅ«tÄ«t pÄ“c visiem mÄ“Ä£inÄjumiem');
  return false;
}

// Improved queue flushing with progress tracking
async function flushQueue() {
  const items = await idbAll();
  if (!items.length) return { sent: 0, left: 0 };
  
  console.log(`SÄku sÅ«tÄ«t ${items.length} failus no rindas...`);
  let sent = 0;
  
  for (const item of items) {
    try {
      console.log(`SÅ«tu failu ${item.id} (${sent + 1}/${items.length})...`);
      const ok = await uploadOne(item.entry, item.dataUri);
      if (ok) {
        await idbDel(item.id);
        sent++;
        console.log(`Fails ${item.id} veiksmÄ«gi nosÅ«tÄ«ts (${sent}/${items.length})`);
      }
    } catch (e) {
      console.error(`KÄ¼Å«da apstrÄdÄjot failu ${item.id}:`, e);
    }
  }
  
  const left = (await idbAll()).length;
  console.log(`SÅ«tÄ«Å¡ana pabeigta. NosÅ«tÄ«ti: ${sent}, AtlikuÅ¡i: ${left}`);
  return { sent, left };
}

// Check available storage space
async function checkStorageQuota() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        const available = estimate.quota - estimate.usage;
        console.log(`PieejamÄ vieta: ${formatBytes(available)}`);
        return available;
    }
    return null;
}

// Compress PDF if needed
async function compressPdfIfNeeded(dataUri) {
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (dataUri.length <= maxSize) return dataUri;

    try {
        // Extract base64 data
        const base64 = dataUri.split(',')[1];
        const binaryString = window.atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        const pdfBlob = new Blob([bytes], { type: 'application/pdf' });

        // Create new PDF with reduced quality
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        const pdfUrl = URL.createObjectURL(pdfBlob);
        
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                try {
                    const canvas = document.createElement('canvas');
                    const ratio = img.width / img.height;
                    canvas.width = 1240; // A4 width at 150dpi
                    canvas.height = canvas.width / ratio;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
                    pdf.addImage(compressedDataUrl, 'JPEG', 0, 0, pdf.internal.pageSize.width, pdf.internal.pageSize.height);
                    resolve(pdf.output('datauristring'));
                } catch (e) {
                    reject(e);
                } finally {
                    URL.revokeObjectURL(pdfUrl);
                }
            };
            img.onerror = reject;
            img.src = pdfUrl;
        });
    } catch (e) {
        console.warn('PDF saspieÅ¡ana neizdevÄs:', e);
        return dataUri; // Return original if compression fails
    }
}

// Improved queueing with enhanced error handling and compression
async function queueOrSend(entry, dataUri) {
    try {
        // Vispirms mÄ“Ä£inÄm iztÄ«rÄ«t vecos datus, ja tÄdi ir
        try {
            const items = await idbAll();
            if (items.length > 0) {
                console.log('MÄ“Ä£inu iztÄ«rÄ«t vecos datus...');
                const oldItems = items.filter(item => {
                    const age = Date.now() - item.addedAt;
                    return age > 7 * 24 * 60 * 60 * 1000; // vecÄki par 7 dienÄm
                });
                for (const item of oldItems) {
                    await idbDel(item.id);
                }
            }
        } catch (e) {
            console.warn('NeizdevÄs iztÄ«rÄ«t vecos datus:', e);
        }

        // PÄrbaudÄm PDF izmÄ“ru
        const dataSize = dataUri.length;
        console.log(`SÄkotnÄ“jais PDF izmÄ“rs: ${formatBytes(dataSize)}`);

        // Ja PDF ir lielÄks par 5MB, mÄ“Ä£inÄm to saspiest
        let finalDataUri = dataUri;
        if (dataSize > 5 * 1024 * 1024) {
            try {
                console.log('PDF ir liels, mÄ“Ä£inu saspiest...');
                const compressedDataUri = await compressPdfIfNeeded(dataUri);
                if (compressedDataUri.length < dataSize) {
                    finalDataUri = compressedDataUri;
                    console.log(`PDF saspiests lÄ«dz ${formatBytes(compressedDataUri.length)}`);
                }
            } catch (e) {
                console.warn('PDF saspieÅ¡ana neizdevÄs:', e);
            }
        }

        // PÄrbaudÄm pieejamo vietu
        try {
            const availableStorage = await checkStorageQuota();
            if (availableStorage !== null) {
                const requiredSpace = finalDataUri.length * 1.5; // PieÄ¼aujam 50% papildus vietu
                if (requiredSpace > availableStorage) {
                    throw new Error(`Nepietiek vietas ierÄ«cÄ“ (NepiecieÅ¡ams: ${formatBytes(requiredSpace)}, Pieejams: ${formatBytes(availableStorage)})`);
                }
            }
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                throw new Error('Nepietiek vietas ierÄ«cÄ“. LÅ«dzu, izdzÄ“siet nevajadzÄ«gos failus vai samaziniet attÄ“lu skaitu.');
            }
            console.warn('NevarÄ“ja pÄrbaudÄ«t pieejamo vietu:', e);
        }

        // Ja ir internets, mÄ“Ä£inÄm sÅ«tÄ«t uzreiz
        if (navigator.onLine) {
            try {
                console.log('MÄ“Ä£inu sÅ«tÄ«t failu uzreiz...');
                const okNow = await uploadOne(entry, finalDataUri);
                if (okNow) {
                    console.log('Fails veiksmÄ«gi nosÅ«tÄ«ts!');
                    return { mode: 'sent' };
                }
            } catch (e) {
                console.warn('TieÅ¡Ä sÅ«tÄ«Å¡ana neizdevÄs:', e);
            }
        }

        // Ja tieÅ¡Ä sÅ«tÄ«Å¡ana neizdevÄs vai nav interneta, saglabÄjam rindÄ
        console.log('SaglabÄju failu rindÄ...');
        
        // Pirms saglabÄÅ¡anas vÄ“lreiz pÄrbaudÄm un iztÄ«ram vecos datus ja nepiecieÅ¡ams
        const currentItems = await idbAll();
        if (currentItems.length >= 30) { // MaksimÄlais nesÅ«tÄ«to failu skaits
            throw new Error('Sasniegts maksimÄlais nesÅ«tÄ«to failu skaits (30). LÅ«dzu, pagaidiet lÄ«dz bÅ«s internets vai izdzÄ“siet vecos failus.');
        }

        // SaglabÄjam rindÄ
        await idbAdd({ 
            entry, 
            dataUri: finalDataUri, 
            addedAt: Date.now(),
            size: finalDataUri.length
        });
        console.log('Fails veiksmÄ«gi saglabÄts rindÄ');

        return { mode: 'queued' };
    } catch (e) {
        console.error('KÄ¼Å«da apstrÄdÄjot failu:', e);
        
        // DetalizÄ“ts kÄ¼Å«das ziÅ†ojums
        let errorMsg;
        if (e.message.includes('QuotaExceededError') || e.message.includes('Nepietiek vietas')) {
            errorMsg = 'Nepietiek vietas ierÄ«cÄ“. LÅ«dzu:\n1. IzdzÄ“siet vecos failus\n2. Samaziniet attÄ“lu skaitu\n3. Samaziniet attÄ“lu izÅ¡Ä·irtspÄ“ju';
        } else if (e.message.includes('maksimÄlais nesÅ«tÄ«to failu skaits')) {
            errorMsg = e.message;
        } else {
            errorMsg = 'NeizdevÄs saglabÄt failu. LÅ«dzu:\n1. Samaziniet attÄ“lu skaitu\n2. Samaziniet attÄ“lu izÅ¡Ä·irtspÄ“ju\n3. MÄ“Ä£iniet vÄ“lreiz, kad ir internets';
        }
        
        throw new Error(errorMsg);
    }
}

// Auto flush on page load & when back online
window.addEventListener('online', () => { flushQueue(); });
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && navigator.onLine) flushQueue();
});

// Submit
form.addEventListener("submit", async (e) => {
  e.preventDefault();
  refreshCompanyUI();
  if (!form.checkValidity()) { form.reportValidity(); return; }

  try {
    msg.textContent = "Samler dataâ€¦";
    const entry = buildEntry();
    const dataUri = await makePdfDataUrlFromForm(entry);

    // Always â€œsendâ€: upload if possible, else queue for later
    const result = await queueOrSend(entry, dataUri);

    msg.textContent = "";

    if (result.mode === 'sent') {
      showCenterSuccess('Sendt!');
    } else {
      showCenterSuccess('Lagret offline', 'Blir sendt automatisk nÃ¥r du er pÃ¥ nett');
    }

    // reset etter OK
    const okBtn = document.getElementById('okSuccess');
    okBtn.onclick = () => {
      hideCenterSuccess();
      form.reset(); pins = []; renderPins(); thumbsEl.innerHTML = "";
      dateInput.value = new Date().toISOString().slice(0,10);
      refreshCompanyUI();
      if (navigator.onLine) flushQueue();
    };
  } catch (err) {
    console.error(err);
    msg.textContent = err.message || "Feil ved sending";
  }
});
</script>

<!-- Centered success popup (pa vidu ekrÄnam) -->
<div id="successCenter" class="success-backdrop" aria-hidden="true">
  <div class="success-pop" role="alertdialog" aria-live="assertive" aria-label="Sendt">
    <div class="icon">âœ“</div>
    <h3 id="successTitle">Sendt!</h3>
    <p id="successSub"></p>
    <button type="button" class="btn" id="okSuccess">OK</button>
  </div>
</div>
  <script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js', { scope: './' })
      .catch(console.error);
  });
}
</body>
</html>
